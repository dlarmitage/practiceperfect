/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, StaleWhileRevalidate, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { clientsClaim } from 'workbox-core';

declare const self: ServiceWorkerGlobalScope;

// Take control immediately
self.skipWaiting();
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// Cache the Google Fonts stylesheets with a stale-while-revalidate strategy
registerRoute(
  /^https:\/\/fonts\.googleapis\.com/,
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

// Cache the underlying font files with a cache-first strategy for 1 year
registerRoute(
  /^https:\/\/fonts\.gstatic\.com/,
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
        maxEntries: 30,
      }),
    ],
  })
);

// Use Network First for API requests
registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 60 * 60 * 24, // 24 hours
      }),
    ],
  })
);

// Handle offline navigation
const navigationHandler = async ({ request }: { event?: ExtendableEvent; request: Request }) => {
  try {
    // Try to get the response from network first
    return await fetch(request);
  } catch (error) {
    // If network fails, try to get from cache
    const cache = await caches.open('offline-cache');
    const cachedResponse = await cache.match('/offline.html');
    
    if (cachedResponse) {
      return cachedResponse;
    }
    
    // If no cached response, return a simple offline message
    return new Response('You are offline. Please check your connection.', {
      status: 503,
      headers: { 'Content-Type': 'text/plain' },
    });
  }
};

// Register the navigation route
registerRoute(new NavigationRoute(navigationHandler));

// Listen for messages from the client
self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
    
    // Notify all clients that we're activating
    self.clients.matchAll().then(clients => {
      clients.forEach(client => {
        client.postMessage({
          type: 'RELOAD_PAGE',
          message: 'New version activated, reloading page...'
        });
      });
    });
  }
});

// Notify clients when an update is available
self.addEventListener('activate', (event) => {
  event.waitUntil(
    (async () => {
      // Get all client IDs
      const clients = await self.clients.matchAll({ type: 'window' });
      
      // Send a message to all clients about the update
      clients.forEach(client => {
        client.postMessage({
          type: 'UPDATE_AVAILABLE',
          message: 'A new version of the app is available!',
        });
      });
    })()
  );
});
